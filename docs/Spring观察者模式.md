# Spring的观察者模式

Spring的观察者模式类似MQ的异步处理, 只不过如果需要异步处理/解耦的业务都在同一个机器上, 那么我们也可以不使用MQ, 而是直接使用Spring提供的观察者模式来实现异步的解耦

## Spring观察者模式中Listener的配置

如果被观察者发送事件(Event)的方法外层存在事务, 那么此时观察者收到事件之后执行对应业务的时候, 有多种选择: 

如果观察者要执行的业务和事件的关系很重要, 那么我们可以让观察者执行的业务和事件放在同一个事务当中, 如果观察者执行的业务失败, 那么事件所在的事务也要跟着回滚, 这个设置我们可以将 `@EventListener`注解改成 `@TransactionalEventListener`, 并且设置注解当中的phase属性为`BEFORE_COMMIT`

如果观察者要执行的业务和事件本身没有太大关联, 即如果观察者执行的业务失败, 那么被观察者不需要回滚, 那么此时我们就可以指定观察者以**异步**的方式来执行业务逻辑, 而不是和被观察者的事件绑定死, 因此这里我们可以配置phase为`AFTER_COMMIT`, 这样就可以保证即使观察者的业务失败, 被观察者的事务仍然不会回滚, 同时, 为了实现 异步执行 的效果, 我们还可以加上 `@Async` 异步注解, 当然前提是我们需要配置了注解对应的默认线程池, 这样就可以异步地执行观察者的逻辑

除此之外, phase还有另外的两种属性, 分别是: `AFTER_ROLLBACK` 以及 `AFTER_COMPLETION`